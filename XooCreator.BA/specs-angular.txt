I'll open the referenced TODO file to understand the current vision and constraints, then propose a concrete reorganization plan for the app and content.

Read TODO specsrefined.txt

Am citit fișierul și propun o reorganizare clară pe features, cu date și servicii distincte pentru “Fun” (Hibride) și “Copacul Imaginației” (premium).

Checklist propus:

Reorganizare structură: core/shared/features + content.
Modelare date: creaturi, carduri, regiuni, progres, credite.
Servicii + store-uri cu signals.
Rute și gărzi pentru premium.
Structură conținut (imagini + JSON) și endpoint-uri backend.
Migrare incrementală, fără a bloca UI-ul curent.
Structură proiect (propunere)
src/app/core/
auth/ AuthService (existent), plus guard simplu
http/ BackendHttpService (existent), interceptors (mai târziu)
state/ PersistenceService (existent), AppState signal-store (opțional)
shared
UI comune (user-menu, butoane, modale, directive)
tipuri/utilitare comune
src/app/features/
home/ (existent)
builder/ (mută creature-builder/* aici, păstrând standalone)
bestiary/
hybrids/ (colecție creații din modul Fun)
transformations/ (carduri obținute din Copac)
imagination-tree/
tree/ vizualizare copac + progres
regions/ galerii de povești+întrebări
stories/ afișare poveste, întrebare grilă, rezultat Card
unlock/ (existent)
profile/, settings/ (placeholder)
services
iz-api.service.ts (existent) – extins pe domenii
credits.service.ts (existent)
progress.service.ts – progres Copac + Animalul Interior
bestiary.service.ts – gestionare Hibride/Transformări (save/list)
tree.service.ts – conținut Copac (regiuni/povești/carduri)
environments (existente)
public/assets/
images/ (existente)
content/
tree/regions.json (regiuni, stories, întrebări)
cards/cards.json (mapare răspuns → Card/atribut/animal)
hybrids/names.json (nume funny pentru generare)
locales/ro.json (opțional pe viitor)
Modele de date (contracte minime)
Creature (Hybrid)
id, name, imageUrl, createdAt, parts: { head, body, tail }
Card (Transformation)
id, title, attribute: 'curiozitate'|'curaj'|'blândețe'|'energie', animalKey, imageUrl, regionKey, storyId
Region
key, title, stories: [Story]
Story
id, title, text, question: { prompt, options: [{id, text, attribute, animalKey}] }
TreeProgress
selectedTreeType, unlockedRegions: string[], earnedCards: Card[], level: 1|2|3
Credits
available: number, premiumUnlocked: boolean
Servicii și state
IZApiService (existent) – extinde cu metode:
GET/POST api/creatures (hybrids)
GET/POST api/cards (transformations)
GET api/tree/regions (conținut copac)
POST api/tree/answer (returnează Card pe baza opțiunii)
GET/POST api/progress (sincronizare progres)
BestiaryService
signals: hybrids[], cards[]
metode: list/save for hybrids/cards (folosește IZApiService)
ProgressService
signals: credits, treeProgress, innerAnimal
metode: addCard(), unlockRegion(), spendCredits(15), hasPremiumAccess()
TreeService
signals: regions, loading, error
metode: fetchRegions(), answerStory(storyId, optionId) → Card
Persistență offline: menține mirror în localStorage (via PersistenceService) pentru mod Fun și read-only cache pentru copac (când e offline).

Rute și gărzi
routes:
/ Home
/builder Builder (free)
/bestiary/hybrids, /bestiary/transformations (free vizualizare)
/imagination-tree (guard: CreditsService.hasEverToppedUp() sau ProgressService.hasPremiumAccess())
/imagination-tree/region/:key (guard idem)
Guards:
premiumGuard – redirecționează la /unlock dacă nu are acces
Conținut și assets
Imagini rămân sub public/images/...
Conținut Copac în JSON:
public/content/tree/regions.json
regiuni (junglă, savană, tundră, norii), cu 3 stories fiecare
public/content/cards/cards.json
definiri carduri + mapping opțiune → cardId
Nume hibride:
public/content/hybrids/names.json – folosit la generare pentru consistență/replay
Avantaje:

Separă clar conținutul de cod (ușor de itera/translate)
Poate fi servit din backend sau din assets în dev
Backend – endpoint-uri minime
GET /api/creatures → Creature[]
POST /api/creatures → Creature
GET /api/cards → Card[]
POST /api/tree/answer { storyId, optionId } → Card
GET /api/tree/regions → Region[]
GET /api/progress → TreeProgress
POST /api/progress → TreeProgress
Note:

Poți începe cu BackendHttpService + IZApiService (existente) și să comuți treptat de pe localStorage pe backend.
Pentru premium, CreditsService/ProgressService coordonează debitarea celor 15 credite și accesul pe rute.
Migrare incrementală (fără a rupe UI)
Conținut
Adaugă public/content/tree/regions.json și cards.json; creează TreeService.fetchRegions().
Bestiar
Creează BestiaryService și mută salvările hibride acolo (în locul direct în component).
Progres
Creează ProgressService (credits + treeProgress); implementează premiumGuard.
Rute
Adaugă /bestiary/*, /imagination-tree/*; montează guard.
UI Tree
În imagination-tree afișează progres (frunze = cards), și acces la regiuni/stories.
Integrare backend
Comută în IZApiService către endpoint-uri reale, când sunt gata.
Edge cases:

Fără backend: folosește assets JSON + localStorage.
Partial premium: dacă are 15 credite dar nu a început copacul → prompt start + debitează.
Re-răspuns la aceeași poveste: returnează același Card sau marchează ca finalizată.
Dacă vrei, pot crea acum scheletele BestiaryService, ProgressService, TreeService și JSON-urile de conținut cu câteva povești demo, plus guard-ul premium.